/* automatically generated by rust-bindgen */

pub type u8 = crate::ctypes::c_uchar;
pub type i8 = crate::ctypes::c_schar;
pub type u16 = crate::ctypes::c_ushort;
pub type i16 = crate::ctypes::c_short;
pub type u32 = crate::ctypes::c_uint;
pub type i32 = crate::ctypes::c_int;
pub type u16x = crate::ctypes::c_uint;
pub type i16x = crate::ctypes::c_int;
pub const H264SwDecRet_H264SWDEC_OK: H264SwDecRet = 0;
pub const H264SwDecRet_H264SWDEC_STRM_PROCESSED: H264SwDecRet = 1;
pub const H264SwDecRet_H264SWDEC_PIC_RDY: H264SwDecRet = 2;
pub const H264SwDecRet_H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY: H264SwDecRet = 3;
pub const H264SwDecRet_H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY: H264SwDecRet = 4;
pub const H264SwDecRet_H264SWDEC_PARAM_ERR: H264SwDecRet = -1;
pub const H264SwDecRet_H264SWDEC_STRM_ERR: H264SwDecRet = -2;
pub const H264SwDecRet_H264SWDEC_NOT_INITIALIZED: H264SwDecRet = -3;
pub const H264SwDecRet_H264SWDEC_MEMFAIL: H264SwDecRet = -4;
pub const H264SwDecRet_H264SWDEC_INITFAIL: H264SwDecRet = -5;
pub const H264SwDecRet_H264SWDEC_HDRS_NOT_RDY: H264SwDecRet = -6;
pub const H264SwDecRet_H264SWDEC_EVALUATION_LIMIT_EXCEEDED: H264SwDecRet = -7;
pub type H264SwDecRet = i32;
pub type H264SwDecInst = *mut crate::ctypes::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct H264SwDecInput {
    pub pStream: *mut u8,
    pub dataLen: u32,
    pub picId: u32,
    pub intraConcealmentMethod: u32,
}
#[test]
fn bindgen_test_layout_H264SwDecInput() {
    assert_eq!(
        ::core::mem::size_of::<H264SwDecInput>(),
        24usize,
        concat!("Size of: ", stringify!(H264SwDecInput))
    );
    assert_eq!(
        ::core::mem::align_of::<H264SwDecInput>(),
        8usize,
        concat!("Alignment of ", stringify!(H264SwDecInput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInput>())).pStream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInput),
            "::",
            stringify!(pStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInput>())).dataLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInput),
            "::",
            stringify!(dataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInput>())).picId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInput),
            "::",
            stringify!(picId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264SwDecInput>())).intraConcealmentMethod as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInput),
            "::",
            stringify!(intraConcealmentMethod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct H264SwDecOutput {
    pub pStrmCurrPos: *mut u8,
}
#[test]
fn bindgen_test_layout_H264SwDecOutput() {
    assert_eq!(
        ::core::mem::size_of::<H264SwDecOutput>(),
        8usize,
        concat!("Size of: ", stringify!(H264SwDecOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<H264SwDecOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(H264SwDecOutput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecOutput>())).pStrmCurrPos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecOutput),
            "::",
            stringify!(pStrmCurrPos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct H264SwDecPicture {
    pub pOutputPicture: *mut u32,
    pub picId: u32,
    pub isIdrPicture: u32,
    pub nbrOfErrMBs: u32,
}
#[test]
fn bindgen_test_layout_H264SwDecPicture() {
    assert_eq!(
        ::core::mem::size_of::<H264SwDecPicture>(),
        24usize,
        concat!("Size of: ", stringify!(H264SwDecPicture))
    );
    assert_eq!(
        ::core::mem::align_of::<H264SwDecPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(H264SwDecPicture))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264SwDecPicture>())).pOutputPicture as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecPicture),
            "::",
            stringify!(pOutputPicture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecPicture>())).picId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecPicture),
            "::",
            stringify!(picId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecPicture>())).isIdrPicture as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecPicture),
            "::",
            stringify!(isIdrPicture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecPicture>())).nbrOfErrMBs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecPicture),
            "::",
            stringify!(nbrOfErrMBs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CropParams {
    pub cropLeftOffset: u32,
    pub cropOutWidth: u32,
    pub cropTopOffset: u32,
    pub cropOutHeight: u32,
}
#[test]
fn bindgen_test_layout_CropParams() {
    assert_eq!(
        ::core::mem::size_of::<CropParams>(),
        16usize,
        concat!("Size of: ", stringify!(CropParams))
    );
    assert_eq!(
        ::core::mem::align_of::<CropParams>(),
        4usize,
        concat!("Alignment of ", stringify!(CropParams))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CropParams>())).cropLeftOffset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CropParams),
            "::",
            stringify!(cropLeftOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CropParams>())).cropOutWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CropParams),
            "::",
            stringify!(cropOutWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CropParams>())).cropTopOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CropParams),
            "::",
            stringify!(cropTopOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CropParams>())).cropOutHeight as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CropParams),
            "::",
            stringify!(cropOutHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct H264SwDecInfo {
    pub profile: u32,
    pub picWidth: u32,
    pub picHeight: u32,
    pub videoRange: u32,
    pub matrixCoefficients: u32,
    pub parWidth: u32,
    pub parHeight: u32,
    pub croppingFlag: u32,
    pub cropParams: CropParams,
}
#[test]
fn bindgen_test_layout_H264SwDecInfo() {
    assert_eq!(
        ::core::mem::size_of::<H264SwDecInfo>(),
        48usize,
        concat!("Size of: ", stringify!(H264SwDecInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<H264SwDecInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(H264SwDecInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).picWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(picWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).picHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(picHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).videoRange as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(videoRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264SwDecInfo>())).matrixCoefficients as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(matrixCoefficients)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).parWidth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(parWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).parHeight as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(parHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).croppingFlag as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(croppingFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecInfo>())).cropParams as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecInfo),
            "::",
            stringify!(cropParams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct H264SwDecApiVersion {
    pub major: u32,
    pub minor: u32,
}
#[test]
fn bindgen_test_layout_H264SwDecApiVersion() {
    assert_eq!(
        ::core::mem::size_of::<H264SwDecApiVersion>(),
        8usize,
        concat!("Size of: ", stringify!(H264SwDecApiVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<H264SwDecApiVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(H264SwDecApiVersion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecApiVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecApiVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264SwDecApiVersion>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(H264SwDecApiVersion),
            "::",
            stringify!(minor)
        )
    );
}
extern "C" {
    pub fn H264SwDecDecode(
        decInst: H264SwDecInst,
        pInput: *mut H264SwDecInput,
        pOutput: *mut H264SwDecOutput,
    ) -> H264SwDecRet;
}
extern "C" {
    pub fn H264SwDecInit(decInst: *mut H264SwDecInst, noOutputReordering: u32) -> H264SwDecRet;
}
extern "C" {
    pub fn H264SwDecNextPicture(
        decInst: H264SwDecInst,
        pOutput: *mut H264SwDecPicture,
        endOfStream: u32,
    ) -> H264SwDecRet;
}
extern "C" {
    pub fn H264SwDecGetInfo(decInst: H264SwDecInst, pDecInfo: *mut H264SwDecInfo) -> H264SwDecRet;
}
extern "C" {
    pub fn H264SwDecRelease(decInst: H264SwDecInst);
}
extern "C" {
    pub fn H264SwDecGetAPIVersion() -> H264SwDecApiVersion;
}
extern "C" {
    pub fn H264SwDecTrace(arg1: *mut crate::ctypes::c_char);
}
extern "C" {
    pub fn H264SwDecMalloc(size: u32) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn H264SwDecFree(ptr: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn H264SwDecMemcpy(
        dest: *mut crate::ctypes::c_void,
        src: *mut crate::ctypes::c_void,
        count: u32,
    );
}
extern "C" {
    pub fn H264SwDecMemset(ptr: *mut crate::ctypes::c_void, value: i32, count: u32);
}
